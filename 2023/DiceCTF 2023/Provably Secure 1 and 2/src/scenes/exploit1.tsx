import { makeScene2D } from '@motion-canvas/2d/lib/scenes';
import { Layout, Circle, Latex, Text } from '@motion-canvas/2d/lib/components';
import { createRef, } from '@motion-canvas/core/lib/utils';
import { delay, chain, all, waitFor } from '@motion-canvas/core/lib/flow';
import {
    CodeBlock,
    edit,
    insert,
    lines,
    remove,
} from '@motion-canvas/2d/lib/components/CodeBlock';
import { timing } from '../util';

export default makeScene2D(function* (view) {
    const code = createRef<CodeBlock>();
    const text = createRef<Text>();

    const codesegments = [
        `elif choice == 1:
    en_count += 1
    if (en_count > 8):
        print("You've run out of encryptions!")
        exit(0)
    m0 = bytes.fromhex(input("m0 (16 byte hexstring): ").strip())
    m1 = bytes.fromhex(input("m1 (16 byte hexstring): ").strip())
    if len(m0) != 16 or len(m1) != 16:
        print("Must be 16 bytes!")
        exit(0)
    msg = m0 if m_bit == 0 else m1
    ct = encrypt(pk0, pk1, msg) # returns hexstring
    seen_ct.add(ct)
    print(ct)`,
        `elif choice == 2:
    de_count += 1
    if (de_count > 8):
        print("You've run out of decryptions!")
        exit(0)
    in_ct = bytes.fromhex(input("ct (512 byte hexstring): ").strip())
    if len(in_ct) != 512:
        print("Must be 512 bytes!")
        exit(0)
    if in_ct in seen_ct: # checking bytestring, not hexstring!
        print("Cannot query decryption on seen ciphertext!")
        exit(0)
    print(decrypt(key0, key1, in_ct).hex())`,
    ];

    const textsegments = [
        `But how do we exploit the code and guess m_bit correctly?`,
        `Well, for Provably Secure 1, there is a fatal flaw hiding in the code.`,
        `If we take a careful look, when we are encrypting, the line seen_ct.add(ct)  
        adds the hex of the encrypted text into the seen_ct set.`,
        `However, when the server is decrypting, it first converts
        the input ciphertext into bytes.`,
        `But it then checks if those bytes are in the seen_ct set, not the original hex!`,
        `We can exploit this as this allows us to decrypt the same ciphertext that 
        we just encrypted.`
    ]

    view.add(
        <Text
            ref={text}
            fill="white"
            fontSize={32}
            fontFamily="monospace"
            maxWidth={1080}
            textWrap={true}
            opacity={0}
            x={0}
        />
    );

    view.add(
        <CodeBlock
            ref={code}
            language="python"
            fill="white"
            fontSize={28}
            fontFamily="monospace"
            maxWidth={1080}
            lineHeight={36}
            opacity={0}
            x={-400}
        />
    );

    yield* chain(
        all(
            text().text(textsegments[0], 1),
            text().opacity(1, 0.5),
        ),
        waitFor(timing(textsegments[0]) - 0.5),
        all(
            text().text(textsegments[1], 0.75),
            text().position.x(550, 0.75),
            text().maxWidth(700, 0.75),
        ),
        waitFor(0.5),
        all(
            code().edit(0.75)`${insert(codesegments[0])}`,
            code().opacity(1, 0.75),
        ),
        waitFor(timing(textsegments[1]) - 2),
    )

    yield* all(
        text().text(textsegments[2], 0.5),
        delay(1,
            code().selection(lines(11, 12), 0.5),

        ),
        waitFor(timing(textsegments[2]) - 1),
    )

    yield* all(
        text().text(textsegments[3], 0.75),
        code().edit(0.5)`${edit(codesegments[0], codesegments[1])}`,
        delay(1,
            all(
                code().selection(lines(5, 5), 0.5),
                delay(1.75,
                    all(
                        text().text(textsegments[4], 0.75),
                        code().selection(lines(9, 9), 0.75),
                        waitFor(timing(textsegments[4])),
                    )
                )
            )
        ),
    )

    yield* all(
        code().edit(0.5)`${remove(codesegments[1])}`,
        text().text(textsegments[5], 1),
        text().position.x(0, 1),
        text().maxWidth(1080, 1),
        waitFor(timing(textsegments[5]) - 1),
    )

    const expsegments = [
        `from pwn import *
from tqdm import tqdm
# nc mc.ax 31493
r = remote('mc.ax', 31493)`,
        `
for i in tqdm(range(128)):`,
        `
    r.recvuntil(b'Action:')
    r.sendline(b'1')
    r.recvuntil(b'm0 (16 byte hexstring):')
    r.sendline(b'0'*32)
    r.recvuntil(b'm1 (16 byte hexstring):')
    r.sendline(b'0'*31 + b'1')`,
        `
    ct = r.recvline().strip()
    `,
        `
    r.recvuntil(b'Action:')
    r.sendline(b'2')
    r.recvuntil(b'ct (512 byte hexstring):')
    r.sendline(ct)`,
        `
    m = r.recvline().strip()
    m = int(m) # 0 or 1
    `,
        `
    r.recvuntil(b'Action:')
    r.sendline(b'0')
    r.recvuntil(b'm_bit guess:')
    r.sendline(str(m).encode())`,
        `r.interactive()`,
    ]

    const descsegments = [
        `Here's the exploit script. We'll be using pwntools to connect to the server.`, // expsegments[0]
        `If you don't know what pwntools is, I highly recommend checking it out. https://docs.pwntools.com/en/stable/`,
        `It's a very useful library for CTFs in general, not just the pwn category.`,
        `As for the exploit, first, we'll create a remote connection to the server through the pwntools remote class.`,
        `Then, because we have to guess m_bit 128 times, we'll use a for loop.`, // expsegments[1]
        `If you're wondering what tqdm does, it just displays a progress bar for the loop (visual only).`,
        `For each iteration, this will be our attack process.`, // expsegments[2]
        `First, we'll send a 1 to encrypt a message.`,
        `We'll then encrypt two unique messages, m0 and m1. It doesn't matter what the messages are, 
        as long as they're different. In this case I'm using literally just 0 and 1 padded to 16 bytes.`,
        `Using recvuntil and sendline, we can communicate with the server through pwntools.`,
        `Then, we'll receive the ciphertext using recvline.`, // expsegments[3]
        `Next, we'll try to decrypt the ciphertext we just received.`, // expsegments[4]
        `We should then receive back one of our original messages, m0 or m1.`, // expsegments[5]
        `In this case, because I chose m0 to be exactly 0 and m1 to be exactly 1, if I cast 
        the decrypted message to an integer, I'll get 0 or 1, exactly matching m_bit.`,
        `To see why, pretend that I got back m1, or 00...01. When I cast this to an integer,
        all the 0's will be ignored and it will be evaluated as 1, exactly matching m_bit because m1 was chosen.`,
        `The same thing happens with m0, or 00...00, evaluating to 0.`,
        `Finally, we'll send our guess, the value of m_bit, to the server.`, // expsegments[6]
        `After we've guessed m_bit 128 times, we can then transform the remote connection into an
        interactive shell, allowing us to finally read the flag.`, // expsegments[7]
        `And that's it! Here's the full exploit script. Running it should give us the flag:`,
        `And that's it! Here's the full exploit script. Running it should give us the flag: dice{yeah_I_lost_like_10_points_on_that_proof_lmao}`,
        `Moving on, we'll be looking at Provable Secure 2, which actually requires us to exploit the encryption.`
    ]

    // SWAP!
    yield* all(
        delay(1, all(
            code().edit(0.5)`${insert(expsegments[0])}`,
        )),
        text().text(descsegments[0], 1),
        text().position.x(-450, 1),
        text().maxWidth(960, 1),
        code().position.x(450, 1),
        waitFor(timing(descsegments[0])),
    )

    yield* chain(
        text().text(descsegments[1], 1),
        waitFor(timing(descsegments[1])),
        text().text(descsegments[2], 1),
        waitFor(timing(descsegments[2])),
    )

    yield* all(
        code().selection(lines(2, 3), 0.5),
        text().text(descsegments[3], 1),
        waitFor(timing(descsegments[3])),
    ),

        yield* all(
            code().edit(0.5)`${expsegments[0]}${insert(expsegments[1])}`,
            text().text(descsegments[4], 1),
            waitFor(timing(descsegments[4])),
        ),

        yield* all(
            code().selection(lines(1, 1), 0.5),
            text().text(descsegments[5], 1),
            waitFor(timing(descsegments[5])),
        ),

        yield* all(
            text().text(descsegments[6], 1),
            code().selection(lines(0, Infinity), 0.5),
            delay(timing(descsegments[6]),
                all(
                    code().edit(1)`${expsegments[0]}${expsegments[1]}${insert(expsegments[2])}`,
                    text().text(descsegments[7], 1),
                )
            )
        ),

        yield* chain(
            waitFor(0.25),
            code().selection(lines(5, 6), 0.5),
            waitFor(timing(descsegments[7]) - 1.25),
            text().text(descsegments[8], 1),
            code().selection(lines(7, 10), 0.5),
            waitFor(timing(descsegments[8]) - 0.5),
        )

        yield* all(
            text().text(descsegments[9], 1),
            code().selection(lines(5, 10), 0.5),
            waitFor(timing(descsegments[9]) + 1),
        )

        yield* all(
            text().text(descsegments[10], 1),
            code().edit(1)`${expsegments[0]}${expsegments[1]}${expsegments[2]}
            ${insert(expsegments[3])}`,
            waitFor(timing(descsegments[10]) + 1),
        )

        yield* all(
            text().text(descsegments[11], 1),
            code().edit(1)`${expsegments[0]}${expsegments[1]}${expsegments[2]}
            ${expsegments[3]}${insert(expsegments[4])}`,
            waitFor(timing(descsegments[11]) + 1),
        )

        yield* all(
            text().text(descsegments[12], 1),
            code().edit(1)`${expsegments[0]}${expsegments[1]}${expsegments[2]}
            ${expsegments[3]}${expsegments[4]}
            ${insert(expsegments[5])}`,
            waitFor(timing(descsegments[12]) + 1),
        )

        yield* chain(
            text().text(descsegments[13], 0.75),
            waitFor(timing(descsegments[13])),
            text().text(descsegments[14], 0.75),
            waitFor(timing(descsegments[14]) + 0.75),
            text().text(descsegments[15], 0.75),
            waitFor(timing(descsegments[15]) + 0.75),
        )

        yield* all(
            text().text(descsegments[16], 1),
            code().edit(1)`${expsegments[0]}${expsegments[1]}${expsegments[2]}
            ${expsegments[3]}${expsegments[4]}
            ${expsegments[5]}${insert(expsegments[6])}`,
            waitFor(timing(descsegments[16]) + 1),
        )
            
        yield* all(
            text().text(descsegments[17], 1),
            code().edit(1)`${expsegments[0]}${expsegments[1]}${expsegments[2]}
            ${expsegments[3]}${expsegments[4]}
            ${expsegments[5]}${expsegments[6]}
${insert(expsegments[7])}`,
            waitFor(timing(descsegments[17]) + 1),
        )

        yield* all(
            text().text(descsegments[18], 1),
            code().selection(lines(0, Infinity), 0.5),
            waitFor(timing(descsegments[18])),
        )
        
        yield* all(
            text().text(descsegments[19], 1),
            waitFor(timing(descsegments[19]) - timing(descsegments[18]) + 1.5),
        )

        yield* code().opacity(0, 1);
        yield* text().opacity(0, 1);


        yield* all(
            text().text(descsegments[20], 0.4),
            text().opacity(1, 1.25),
            text().position.x(0, 0.4),
            text().fontSize(42, 0.4),
            waitFor(timing(descsegments[20]) + 0.5),
        )

        yield* text().opacity(0, 1);
});