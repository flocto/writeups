import { makeScene2D } from '@motion-canvas/2d/lib/scenes';
import { Layout, Circle, Latex, Text } from '@motion-canvas/2d/lib/components';
import { createRef, } from '@motion-canvas/core/lib/utils';
import { delay, chain, all, waitFor } from '@motion-canvas/core/lib/flow';
import {
    CodeBlock,
    edit,
    insert,
    lines,
    remove,
} from '@motion-canvas/2d/lib/components/CodeBlock';
import { timing } from '../util';

export default makeScene2D(function* (view) {
    const code = createRef<CodeBlock>();
    const text = createRef<Text>();

    const codesegments = [
        `from pwn import *
from tqdm import tqdm
# nc mc.ax 31497
r = remote('mc.ax', 31497)

for i in tqdm(range(128)):
`,
        `    r.recvuntil(b'Action:')
    r.sendline(b'1')
    r.recvuntil(b'm0 (16 byte hexstring):')
    r.sendline(b'0'*32)
    r.recvuntil(b'm1 (16 byte hexstring):')
    r.sendline(b'0'*31 + b'1')
    ct1 = r.recvline().strip()

`,
        `    r.recvuntil(b'Action:')
    r.sendline(b'1')
    r.recvuntil(b'm0 (16 byte hexstring):')
    r.sendline(b'0'*32 )
    r.recvuntil(b'm1 (16 byte hexstring):')
    r.sendline(b'0'*31 + b'2')
    ct2 = r.recvline().strip()

`,
        `    dt1 = ct1[:512] + ct2[512:]
    dt2 = ct2[:512] + ct1[512:]
    
`,
        `    r.recvuntil(b'Action:')
    r.sendline(b'2')
    r.recvuntil(b'ct (512 byte hexstring):')
    r.sendline(dt1)
    m1 = r.recvline().strip()

`,
        `    r.recvuntil(b'Action:')
    r.sendline(b'2')
    r.recvuntil(b'ct (512 byte hexstring):')
    r.sendline(dt2)
    m2 = r.recvline().strip()

`,
        `    m = int(m1 != m2)
`,
        `    r.recvuntil(b'Action:')
    r.sendline(b'0')
    r.recvuntil(b'm_bit guess:')
    r.sendline(str(m).encode())

`,
        `r.interactive()`]

    const textsegments = [
        `Let's look at the actual exploit script now.`,
        `We'll begin with the same imports and for loop from before.`,
        `Again, we'll start by encrypting m0: 00..00, m1: 00..01.`,
        `This time, we'll also encrypt another pair, m0: 00..00, m2: 00..02.`,
        `Now we can swap the ciphertext parts for each encryption pair.`,
        `Next we'll have both swapped pairs decrypted.`,
        `If they're the same, we know that m0 was encrypted both times, so m_bit must be 0.`,
        `If they're different, then m1 and m2 must have been encrypted, so m_bit is 1.`,
        `We can do shortcut this with a simple cast to int again, as m1 != m2 becomes 1 and m1 == m2 becomes 0.`,
        `Then we send back our guess to the server,`,
        ` and after 128 tries, we should get the flag.`,
        `Running the script gives us: `,
        `dice{my_professor_would_not_be_proud_of_me}`,
    ]

    view.add(
        <Text
            ref={text}
            fill="white"
            fontSize={36}
            fontFamily="monospace"
            maxWidth={1080}
            textWrap={true}
            opacity={0}
            x={0}
        />
    );

    view.add(
        <CodeBlock
            ref={code}
            language="py"
            fill="white"
            fontSize={28}
            fontFamily="monospace"
            maxWidth={1080}
            lineHeight={36}
            opacity={0}
            x={400}
        />
    );

    yield* all(
        text().opacity(1, 1),
        text().text(textsegments[0], 1),
        waitFor(timing(textsegments[0]) + 1),
    )

    yield* all(
        text().position.x(-400, 1),
        text().text(textsegments[1], 0.75),
        text().fontSize(32, 1),
        text().size.x(1000, 1),
        code().opacity(1, 1),
        code().edit(1.5)`${insert(codesegments[0])}`,
        waitFor(timing(textsegments[1]) + 1),
    )

    yield* all(
        text().text(textsegments[2], 0.75),
        code().edit(1.5)`${codesegments[0]}${insert(codesegments[1])}`,
        waitFor(timing(textsegments[2]) + 0.75),
    )

    yield* all(
        text().text(textsegments[3], 0.75),
        code().edit(1.5)`${codesegments[0]}${codesegments[1]}${insert(codesegments[2])}`,
        waitFor(timing(textsegments[3]) + 0.75),
    )

    yield* all(
        text().text(textsegments[4], 0.75),
        code().edit(1.5)`${codesegments[0]}${codesegments[1]}${codesegments[2]}${insert(codesegments[3])}`,
        waitFor(timing(textsegments[4]) + 0.75),
    )

    yield* all(
        text().text(textsegments[5], 0.75),
        code().edit(1.5)`${codesegments[0]}${remove(codesegments[1])}${remove(codesegments[2])}${codesegments[3]}${insert(codesegments[4])}`,
    )

    yield* all(
        code().edit(1.5)`${codesegments[0]}${codesegments[3]}${codesegments[4]}${insert(codesegments[5])}`,
        waitFor(timing(textsegments[5]) - 1.5),
    )

    yield* all(
        text().text(textsegments[6], 0.75),
        code().selection(lines(9, Infinity), 0.5),
        waitFor(timing(textsegments[6]) + 0.5),
    )

    yield* all(
        text().text(textsegments[7], 0.75),
        waitFor(timing(textsegments[7]) + 0.5),
    )

    yield* all(
        text().text(textsegments[8], 0.75),
        code().edit(1.5)`${codesegments[0]}${codesegments[3]}${codesegments[4]}${codesegments[5]}${insert(codesegments[6])}`,
        waitFor(timing(textsegments[8]) + 0.75),
    )

    yield* all(
        text().text(textsegments[9], 0.75),
        code().edit(1.5)`${codesegments[0]}${codesegments[3]}${codesegments[4]}${codesegments[5]}${codesegments[6]}${insert(codesegments[7])}`,
        delay(1.75, all(
            text().text(textsegments[9] + textsegments[10], 0.75),
            code().edit(1.5)`${codesegments[0]}${codesegments[3]}${codesegments[4]}${codesegments[5]}${codesegments[6]}${codesegments[7]}${insert(codesegments[8])}`,
            waitFor(timing(textsegments[10]) + 0.75),
        ))
    )

    yield* all(
        text().text(textsegments[11], 0.75),
        waitFor(timing(textsegments[11]) + 0.75),
    )

    yield* all(
        text().text(textsegments[11] + textsegments[12], 0.75),
        waitFor(1.5),
    )

    yield* code().opacity(0, 1);    
    yield* text().opacity(0, 1);

    const final = [
        `And that's it!`,
        `Thanks for watching both of these writeups.`,
        `I hope you enjoyed them and also learned something new along the way.`,
        `Until next time!`,
        `jk im never making these again this took way too long (2 wks lol)`
    ]

    yield* all(
        text().fontSize(48, 0),
        text().minWidth(1440, 0),
        text().lineHeight(60, 0),
        text().position([0, 0], 0),
        text().text(final[0], 0.1),
        text().justifyContent("center", 0),
        text().alignItems("center", 0),
        text().opacity(1, 1),
        waitFor(timing(final[0]) + 1),
    )

    yield* all(
        text().text(final[1], 0.75),
        waitFor(timing(final[1]) + 0.75),
    )

    yield* all(
        text().text(final[2], 0.75),
        waitFor(timing(final[2]) + 0.75),
    )

    yield* all(
        text().text(final[3], 0.75),
        waitFor(timing(final[3]) + 1.5),   
    )

    yield* all(
        text().opacity(0, 2),
    )

    yield* all(
        text().fontSize(24, 0),
        text().position([0, 300], 0),
        text().opacity(1, 0.5),
        text().text(final[4], 0),
    )

    yield* text().opacity(0, 0.4);
});